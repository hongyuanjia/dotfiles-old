let g:spacevim_plug_home = '~/.vim/plugged'

" Layers {
function! Layers()
  Layer 'unite'

  Layer 'fzf'

  Layer 'better-defaults', {'exclude': [
        \ 'xtal8/traces.vim',
        \ 't9md/vim-choosewin'
        \ ]}

  Layer 'which-key'

  Layer 'code-snippets'

  " Layer 'markdown'

  Layer 'programming', {'exclude' : [
        \ 'sheerun/vim-polyglot',
        \ 'junegunn/rainbow_parentheses.vim',
        \ 'matze/vim-move',
        \ 'Yggdroot/indentLine'
        \ ]}

  Layer 'text-align'

  Layer 'file-manager', {'exclude': 'danro/rename.vim'}

  Layer 'auto-completion'

  Layer 'airline'

  Layer 'git'
endfunction
" }

" Plugins {
function! UserInit()
  " For save sessions
  Plug 'tpope/vim-obsession'

  " For Git
  Plug 'jreybert/vimagit'

  " For better defaults
  Plug 'tpope/vim-sensible'
  Plug 'tpope/vim-sleuth'
  Plug 'tpope/vim-repeat'
  Plug 'tpope/vim-eunuch'

  " For Unite
  Plug 'Shougo/unite-outline'
  Plug 'thinca/vim-qfreplace'
  Plug 'Shougo/neomru.vim'
  Plug 'Shougo/vimproc.vim', {'do' : 'make'}

  " For R
  Plug 'jalvesaq/Nvim-R', {'commit' : 'd6c9a8a3a2fd6aecb4ab00ce530cbec1054eab2f'}
  Plug 'jalvesaq/R-Vim-runtime'
  Plug 'rafaqz/citation.vim'
  Plug 'gabrielelana/vim-markdown'

  " For Text editing
  Plug 'tpope/vim-surround'
  Plug 'terryma/vim-multiple-cursors'
  Plug 'justinmk/vim-sneak'
  Plug 'jiangmiao/auto-pairs'
  Plug 'kana/vim-textobj-user'
  Plug 'Julian/vim-textobj-variable-segment'
  Plug 'Julian/vim-textobj-brace'
  Plug 'terryma/vim-expand-region'
  Plug 'tpope/vim-commentary'
  Plug 'AndrewRadev/sideways.vim'

  " File Manager
  Plug 'francoiscabrol/ranger.vim'
  Plug 'tyru/open-browser.vim'

  " For better looking
  Plug 'ryanoasis/vim-devicons'
  Plug 'chrisbra/Colorizer'

endfunction
" }

function! UserConfig()

  " Change to file's directory when vim-rooter failed
  let g:rooter_change_directory_for_non_project_files = 'current'

  " better defaults {
  set dictionary+=$HOME/.vim/dict/english.dic
  set complete+=k
  set guifont=DejaVuSansMono\ NF:h12
  set guifontwide=SimHei:h12
  set guioptions-=m
  set showtabline=2
  set expandtab
  set textwidth=80
  set list!
  set listchars=tab:>\ ,trail:-,extends:>,precedes:<,nbsp:+
  set formatoptions+=M "don't insert a space before or after a multi-byte when join
  set formatoptions+=m "Multibyte line breaking
  set formatoptions+=j "Remove a comment leader when joining
  set formatoptions+=q "New line will start with a commen leader
  set formatoptions+=n "When formatting text, recognize numbered lists
  set formatoptions+=r
  set formatoptions-=t

  " https://github.com/liuchengxu/space-vim/issues/184
  if (has("gui"))
    set <F20>=
    set <F21>=
    iunmap jj
    vunmap <F20>
    vunmap <F21>
    nunmap <F20>
    nunmap <F21>

    " for different cursor shapes
    " http://vim.wikia.com/wiki/Change_cursor_shape_in_different_modes
    let &t_SI = "\<Esc>[6 q"
    let &t_SR = "\<Esc>[4 q"
    let &t_EI = "\<Esc>[2 q"
  endif

  " disable meta keybindings in rsi.vim
  let g:rsi_no_meta = 1

  noremap - <Nop>
  autocmd GUIEnter * simalt ~x

  " Quick command mode
  nnoremap ; :
  nnoremap : ;
  " Visual select to beginning or end
  vnoremap H ^
  vnoremap L $
  " }

  " better key bindings for UltiSnipsExpandTrigger {
  let g:UltiSnipsExpandTrigger = "<tab>"
  let g:UltiSnipsJumpForwardTrigger = "<tab>"
  let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"
  " }

  " Use gui colors in terminal if available {
  function! s:enable_termgui()
    if has('termguicolors')
      set termguicolors
      if g:spacevim.tmux
        " If use vim inside tmux, see https://github.com/vim/vim/issues/993
        " set Vim-specific sequences for RGB colors
        let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
        let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
      endif
    endif
  endfunction
  " If your terminal(-emulator) supports true colors, uncomment the line below
  call s:enable_termgui()
  " }

  " Load auto-pairs when first start to insert {
  augroup spacevimAutoPairs
    autocmd!
    autocmd CursorHold,CursorHoldI,InsertEnter * call plug#load('auto-pairs') | autocmd! spacevimAutoPairs
  augroup END
  " }

  " Overwrite default leaderGuide settings and add new ones {
  " Files {
  nnoremap <silent> <Leader>ft :Ranger<CR>
  nnoremap <silent> <Leader>fv :e $HOME/.spacevim<CR>
  nnoremap <silent> <Leader>fr :History<CR>
  " }
  " Search {
  nnoremap <silent> <Leader>so :Unite -start-insert -toggle outline<CR>
  nnoremap <silent> <Leader>sp :Unite -start-insert grep:.<CR>
  nnoremap <silent> <Leader>sl :Unite -start-insert line<CR>
  " }
  " }

  " Unite settings {
  let g:unite_source_rec_async_command = ['pt', '--nocolor', '--nogroup', '--smart-case']
  let g:unite_source_grep_command='pt'
  let g:unite_source_grep_default_opts='--nocolor --nogroup --smart-case'
  let g:unite_source_grep_recursive_opt = ''
  " }

  " R {
  if (!has("win32"))
    set <M-=>==
    set <M-;>=;
    imap = <M-=>
    imap ; <M-;>
  endif

  " AutoCmd {
  augroup au_R
    au!
    au FileType r,rmd setlocal colorcolumn=80

    au FileType r setlocal foldmethod=marker
    au FileType r setlocal foldmarker={{{,}}}

    au FileType r setlocal commentstring=#%s
    au FileType r setlocal comments+=b:#'

    au FileType rmd setlocal commentstring=<!--%s-->
    au FileType rmd setlocal comments=b:*,b:-,b:+,n:>

    " Keybindings
    if (has("win32"))
      au FileType r,rmd inoremap <buffer> Â½ <c-v><Space>%>%<c-v><Space>
      au FileType r,rmd inoremap <buffer> Â» <c-v><Space>:=<c-v><Space>
    endif
    au FileType r,rmd inoremap <buffer> <M-=> <c-v><Space>%>%<c-v><Space>
    au FileType r,rmd inoremap <buffer> <M-;> <c-v><Space>:=<c-v><Space>
    au FileType r,rmd nnoremap <buffer> <LocalLeader>da :RSend devtools::load_all()<cr>
    au FileType r,rmd nnoremap <buffer> <LocalLeader>tb :RSend traceback()<cr>
    au FileType r,rmd nnoremap <buffer> <LocalLeader>sq :RSend Q<cr>
    au FileType r,rmd nnoremap <buffer> <LocalLeader>sc :RSend c<cr>
    au FileType r,rmd nnoremap <buffer> <LocalLeader>sn :RSend n<cr>
    au FileType rbrowser nnoremap <buffer><silent> <CR> :call RBrowserDoubleClick()<CR>
    au FileType rbrowser nnoremap <buffer><silent> <2-LeftMouse> :call RBrowserDoubleClick()<CR>
    au FileType rbrowser nnoremap <buffer><silent> <RightMouse> :call RBrowserRightClick()<CR>
    au FileType rmd nnoremap <buffer> <LocalLeader>kk :call RenderRmd()<CR>
    au FileType rmd nnoremap <buffer> <LocalLeader>kb :call RenderBook()<CR>

    au FileType rmd noremap <leader>z "=ZoteroCite()<CR>p
    au FileType rmd inoremap <C-z> <C-r>=ZoteroCite()<CR>
    au FileType rmd nmap <Leader>u [unite]
    au FileType rmd nnoremap [unite] <nop>
    " To insert a citation
    au FileType rmd nnoremap <silent>[unite]cc :<C-u>Unite -buffer-name=citation -start-insert -default-action=append citation/key<cr>
    " To immediately open a file from a citation under the cursor
    au FileType rmd nnoremap <silent>[unite]co :<C-u>Unite -input=<C-R><C-W> -default-action=start -force-immediately citation/file<cr>
    " To view all citation information from a citation under the cursor:
    au FileType rmd nnoremap <silent>[unite]ci :<C-u>Unite -input=<C-R><C-W> -default-action=preview -force-immediately citation/combined<cr>

    " Switch to R buffer
    if (!has("win32"))
      au FileType r,rmd nnoremap <buffer> <LocalLeader><LocalLeader>r :buffer !R<CR>
    endif
  augroup END
  " }

  nnoremap <buffer> <Leader>tS :call ToggleSpace()<CR>
  function! ToggleSpace()
      let showed = &listchars
      if showed=~#"space"
        set listchars-=space:Â·
      else
        set listchars+=space:Â·
      endif
  endfunction

  function! ZoteroCite()
    " pick a format based on the filetype (customize at will)
    let format = &filetype =~ '.*tex' ? 'citep' : 'pandoc'
    let api_call = 'http://localhost:23119/better-bibtex/cayw?format='.format.'&brackets=1'
    let ref = system('curl -s '.shellescape(api_call))
    return ref
  endfunction

  " RenderRmd {
  function RenderRmd()
    let rmdPath = expand("%:p")
    if has("win32")
      let rmdPath = substitute(rmdPath, '\\', '/', 'g')
    endif
    let cmd = "RSend rmarkdown::render('" . rmdPath. "', encoding = 'UTF-8')"
    exec cmd
  endfunction
  " }
  " RenderBook {
  function RenderBook()
    let rmdPath = expand("%:p")
    if has("win32")
      let rmdPath = substitute(rmdPath, '\\', '/', 'g')
    endif
    let cmd = "RSend bookdown::render_book('" . rmdPath. "', encoding = 'UTF-8')"
    exec cmd
  endfunction
  " }
  " }

  " sideways {
  omap aa <Plug>SidewaysArgumentTextobjA
  xmap aa <Plug>SidewaysArgumentTextobjA
  omap ia <Plug>SidewaysArgumentTextobjI
  xmap ia <Plug>SidewaysArgumentTextobjI
  nnoremap <leader>ah :SidewaysLeft<cr>
  nnoremap <leader>al :SidewaysRight<cr>
  " }

  " sneak {
  let g:sneak#s_next = 1
  " }

  " Auto-pairs {
  " Disable all keybindings
  let g:AutoPairsMapCR = 0
  let g:AutoPairsShortcutFastWrap = ''
  let g:AutoPairsShortcutJump = ''
  let g:AutoPairsShortcutBackInsert = ''
  " }

  " Markdown {
  let g:previm_open_cmd = ''
  " }

  " vim-multiple-cursors {
    let g:multi_cursor_use_default_mapping=0
    let g:multi_cursor_next_key='<C-j>'
    let g:multi_cursor_prev_key='<C-k>'
    let g:multi_cursor_skip_key='<C-x>'
    let g:multi_cursor_quit_key='<Esc>'
  " }

  " Ranger {
  let g:ranger_map_keys = 0
  " }

  " Citation {
  let g:citation_vim_zotero_version=5
  let g:citation_vim_zotero_path = "~/Dropbox/literatures/Zotero/"
  let g:citation_vim_zotero_attachment_path= "~/Dropbox/literatures/attachments"
  let g:citation_vim_cache_path='~/.cache/vim-citation'
  let g:citation_vim_outer_prefix="["
  let g:citation_vim_inner_prefix="@"
  let g:citation_vim_suffix="]"
  let g:citation_vim_collection='Dissertation'
  " }

  " Toggle file path slash {
  function! ToggleSlash(independent) range
    let from = ''
    for lnum in range(a:firstline, a:lastline)
      let line = getline(lnum)
      let first = matchstr(line, '[/\\]')
      if !empty(first)
        if a:independent || empty(from)
          let from = first
        endif
        let opposite = (from == '/' ? '\' : '/')
        call setline(lnum, substitute(line, from, opposite, 'g'))
      endif
    endfor
  endfunction
  command! -bang -range ToggleSlash <line1>,<line2>call ToggleSlash(<bang>1)
  nnoremap <Leader>r<BSlash> :ToggleSlash<CR>
  " }

  " SynGroup{
  function! SynGroup()
      let l:s = synID(line('.'), col('.'), 1)
      echo synIDattr(l:s, 'name') . ' -> ' . synIDattr(synIDtrans(l:s), 'name')
  endfun
  " }

  " tagbar for markdown {
  if has("win32")
    let g:tagbar_ctags_bin="c:/tools/ctags/ctags.exe"
    let g:tagbar_type_rmd = {
          \   'ctagstype':'rmd',
          \   'ctagsbin': $HOME.'/.vim/rmd2ctags/rmd2ctags.bat',
          \   'ctagsargs':'',
          \   'kinds':['y:yaml:1', 'h:header', 'c:chunk'],
          \   'sro':'&&&',
          \   'kind2scope':{'y':'yaml', 'h':'header', 'c':'chunk'},
          \   'sort':0
          \ }
  else
    let g:tagbar_type_rmd = {
          \   'ctagstype':'rmd',
          \   'ctagsbin': $HOME.'/.vim/rmd2ctags/rmd2ctags.R',
          \   'ctagsargs':'',
          \   'kinds':['y:yaml:1', 'h:header', 'c:chunk'],
          \   'sro':'&&&',
          \   'kind2scope':{'y':'yaml', 'h':'header', 'c':'chunk'},
          \   'sort':0
          \ }
  endif
  let g:tagbar_type_markdown = {
        \ 'ctagstype': 'markdown',
        \ 'ctagsbin' : '~/.vim/markdown2ctags/markdown2ctags.py',
        \ 'ctagsargs' : '-f - --sort=yes',
        \ 'kinds' : ['s:sections', 'i:images'],
        \ 'sro' : '|',
        \ 'kind2scope' : {'s' : 'section'},
        \ 'sort': 0
        \ }
  " }

  nnoremap  <Leader>tS :call ToggleSpace()<CR>
  let g:markdown_enable_folding = 1
  let loaded_matchparen = 1
  set noshowmatch

  function! g:DisableThatMatchParen ()
      if exists(":NoMatchParen")
          :NoMatchParen
      endif
  endfunction

  augroup plugin_initialize
      autocmd!
      autocmd VimEnter * call DisableThatMatchParen()
  augroup END
endfunction

  " Nvim-R {
  if has("win32")
    let R_source = "~/.vim/send.vim"
  endif
  let r_indent_align_args = 0
  let rmd_syn_hl_chunk = 1
  " not losing focus every time that you generate the pdf
  let R_openpdf = 1
  let R_nvimpager = "horizontal"
  " open html output
  let R_openhtml = 1
  " highlight R functions only if the `(` is typed
  " let R_hl_fun_paren = 1
  let R_hl_term = 1
  " lists the arguments of a function, but and also the arguments of its methods
  let R_objbr_opendf = 0
  let Rout_more_colors = 1
  let R_objbr_openlist = 0
  " show a preview window of function arguments description and arguments
  let R_show_arg_help = 1
  let R_commented_lines = 1
  if (has("win32"))
    let R_assign_map = "<M-->"
  else
    let R_assign_map = "-"
  endif
  " clear R Console line before sending commands~
  let R_clear_line = 1
  let R_source_args = "print.eval = TRUE, local = TRUE, encoding = 'UTF-8'"
  if has("win32")
    let R_in_buffer = 0
  endif
  " Auto quit R when close Vim
  autocmd VimLeave * if exists("g:SendCmdToR") && string(g:SendCmdToR) != "function('SendCmdToR_fake')" | call RQuit("nosave") | endif
  " }
